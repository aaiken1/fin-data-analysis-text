
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Portfolio optimization &#8212; Data Analysis in Finance</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Factor models" href="10_factor_models.html" />
    <link rel="prev" title="Essential portfolio math" href="8_port_math.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/cat.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Data Analysis in Finance</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Welcome!
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting Started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="1_finpyth.html">
   Why Python and finance?
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="2_intro.html">
   Python set-up
   <a id="python_set-up">
   </a>
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="2_0_install.html">
     Installation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="2_1_jupyter.html">
     Jupyter notebooks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="2_2_vscode.html">
     VS Code
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="2_3_markdown.html">
     Markdown
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="2_4_packages.html">
     Packages
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  The Basics
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="3_intro.html">
   CompSci 101: Types, control, and numpy arrays
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="3_0_comp101.html">
     The Basics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="3_1_numpy.html">
     Numpy and arrays
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="4_intro.html">
   Pandas and data
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="4_0_dataframes.html">
     Data importing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="4_1_pandas.html">
     pandas
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="4_2_cleaning_data.html">
     Cleaning our data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="4_3_eda.html">
     Exploratory data analysis (EDA)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="4_4_merge_shape.html">
     Merging and reshaping data
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="5_intro.html">
   Data visualization
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="5_0_matplotlib.html">
     matplotlib
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="5_1_plotly.html">
     plotly
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="5_2_seaborn.html">
     seaborn
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="6_financial_ts.html">
   Financial time series
   <a id="financial-time-series">
   </a>
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Applications
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="7_nasdaq_api.html">
   Using NASDAQ BTC data
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="8_port_math.html">
   Essential portfolio math
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Portfolio optimization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="10_factor_models.html">
   Factor models
   <a id="factor_models">
   </a>
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="11_risk_mang.html">
   Risk management
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="12_finmarketpy.html">
   Finmarketpy package
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="13_options.html">
   Option basics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="14_monte_carlo.html">
   Monte Carlo and portfolios
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="15_logit_credit.html">
   Credit modeling with logit regressions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="16_time_vol.html">
   More financial time series with volatility
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Labs
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="lab_intro.html">
   Our labs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lab01.html">
   Lab 01
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lab02.html">
   Lab 02
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lab03.html">
   Lab 03
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lab04.html">
   Lab 04
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lab05.html">
   Lab 05
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lab06.html">
   Lab 06
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Exams
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="exam_intro.html">
   Our Exams
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="exam01.html">
   Midterm Exam
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/chapters/9_portfolio_opt.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/executablebooks/jupyter-book"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/executablebooks/jupyter-book/master?urlpath=tree/docs/chapters/9_portfolio_opt.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#getting-started">
   Getting started
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#plotting-the-efficient-frontier">
   Plotting the efficient frontier
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#optimizing">
   Optimizing
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#finding-the-max-sharpe-portfolio">
     Finding the max Sharpe portfolio
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#finding-the-minimum-variance-portfolio">
     Finding the minimum variance portfolio.
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#efficient-frontier">
   Efficient Frontier
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#pyportfolioopt">
   PyPortfolioOpt
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Portfolio optimization</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#getting-started">
   Getting started
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#plotting-the-efficient-frontier">
   Plotting the efficient frontier
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#optimizing">
   Optimizing
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#finding-the-max-sharpe-portfolio">
     Finding the max Sharpe portfolio
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#finding-the-minimum-variance-portfolio">
     Finding the minimum variance portfolio.
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#efficient-frontier">
   Efficient Frontier
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#pyportfolioopt">
   PyPortfolioOpt
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="portfolio-optimization">
<h1>Portfolio optimization<a class="headerlink" href="#portfolio-optimization" title="Permalink to this headline">¶</a></h1>
<p>Portfolio optimization is an important part of many quantitative strategies. You take some inputs related to risk and return and you try to find the portfolio with the desired characteristics. Those characteristics might be something like the best risk-reward trade-off, often given with a Sharpe Ratio. Or, you might be trying to find a portfolio with a particular expected return and the lowest possible risk to get that return.</p>
<p>We’ll start with the example of portfolio optimization using <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code>, very similar to the code found in Chapter 13 of our textbook. This is very much like using <strong>Solver in Excel</strong>. You are having Python numerically solve an optimization problem with some set of constraints or limits on the answer. This means that Python will try to guess values until it gets really, really close to the “best” possible solution.</p>
<p>We are also going to see some interesting Python. We’ll use <strong>tuples</strong>, a basic (primitive) data type in Python. We have <strong>for</strong> loops. We’ll <strong>define our own functions</strong>. We’ll even use something called a <strong>lambda function</strong>.</p>
<p>Finally, we’ll use the <code class="docutils literal notranslate"><span class="pre">PyPortfolioOpt</span></code> <a class="reference external" href="https://pypi.org/project/pyportfolioopt/">package</a>, which is also discussed in the DataCamp assignments. This lets us avoid some of the more math-like aspects of using <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code> and have a library do the work for us using more familiar finance terms. Still, I think it is really important to understand at least a little bit about the optimization process itself. These tools are used in all sorts of applications.</p>
<div class="section" id="getting-started">
<h2>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<p>Let’s bring in our usual set of prices, pick four assets, calculate <strong>discrete</strong> returns, and plot a histogram of those returns.</p>
<p>We are going to use <strong>discrete</strong> (or simple, or arithmetic) returns instead of <strong>log</strong> returns, because we are doing <strong>portfolio optimization</strong>. In short, the return of a portfolio is the weighted average of the mean discrete returns. This is not true for mean log returns.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read in some eod prices</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">mpl</span><span class="p">,</span> <span class="n">plt</span>

<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">sco</span>

<span class="n">raw</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;https://raw.githubusercontent.com/aaiken1/fin-data-analysis-python/main/data/tr_eikon_eod_data.csv&#39;</span><span class="p">,</span>
                  <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span> 

<span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;AAPL.O&#39;</span><span class="p">,</span> <span class="s1">&#39;MSFT.O&#39;</span><span class="p">,</span> <span class="s1">&#39;SPY&#39;</span><span class="p">,</span> <span class="s1">&#39;GLD&#39;</span><span class="p">]</span> <span class="c1">#two stocks and two ETFs</span>

<span class="n">noa</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="c1">#noa = number of assets</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="n">symbols</span><span class="p">]</span>

<span class="n">rets</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">pct_change</span><span class="p">()</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>

<span class="n">rets</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/9_portfolio_opt_2_0.png" src="../_images/9_portfolio_opt_2_0.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rets</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL.O</th>
      <th>MSFT.O</th>
      <th>SPY</th>
      <th>GLD</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>2137.000000</td>
      <td>2137.000000</td>
      <td>2137.000000</td>
      <td>2137.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>0.000969</td>
      <td>0.000643</td>
      <td>0.000452</td>
      <td>0.000088</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.015900</td>
      <td>0.014221</td>
      <td>0.009313</td>
      <td>0.010170</td>
    </tr>
    <tr>
      <th>min</th>
      <td>-0.123549</td>
      <td>-0.113995</td>
      <td>-0.065123</td>
      <td>-0.087808</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>-0.006883</td>
      <td>-0.006745</td>
      <td>-0.003418</td>
      <td>-0.005084</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>0.000667</td>
      <td>0.000308</td>
      <td>0.000580</td>
      <td>0.000343</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>0.009597</td>
      <td>0.007896</td>
      <td>0.005071</td>
      <td>0.005317</td>
    </tr>
    <tr>
      <th>max</th>
      <td>0.088741</td>
      <td>0.104522</td>
      <td>0.046499</td>
      <td>0.049122</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These four return series each have the same number of observations. This is important when doing correlation and covariance matrices. You’ll likely want to just keep observations where none of the assets have missing returns. This is another reason why using historical data can be tricky - for a lot of specific assets, we just don’t have much data!</p>
</div>
<p>We can find the average daily return of each of these four sets of discrete returns and annualize them.</p>
<p>How should we do this? I am going to take the arithmetic mean (i.e. the usual average) and multiply by 252, the number of trading days in the year. This is a common way to go from daily to annual returns when doing portfolio optimization. This generalizes to monthly (12) and quarterly (4).</p>
<p>We’ll do the same thing when using the <code class="docutils literal notranslate"><span class="pre">PyPortfolioOpt</span></code> package. Note that this method does not take into account compounding. You could also annualize the arithmetic average of the monthly returns using <strong>geometric chaining</strong>, or <span class="math notranslate nohighlight">\((1+mean)^{252}-1\)</span>. This will get you the annual return if you earned the mean daily return every day for 252 days. Finally, you could annualize the <strong>geometric mean</strong> of the daily returns using the same chaining principle. If you search around, you’ll find people doing all three.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rets</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">*</span> <span class="mi">252</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>AAPL.O    0.244313
MSFT.O    0.162139
SPY       0.113901
GLD       0.022214
dtype: float64
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ann_rets</span> <span class="o">=</span> <span class="n">rets</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">*</span> <span class="mi">252</span>
</pre></div>
</div>
</div>
</div>
<p>We’ll do something similar for our variance and covariance terms. We are going to take a short-cut and annualize the daily variances and covariances by multiplying by 252. You would annualize standard deviation by multiplying by <span class="math notranslate nohighlight">\(\sqrt{252}\)</span>. Technically, you should only do this with log returns.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rets</span><span class="o">.</span><span class="n">cov</span><span class="p">()</span> <span class="o">*</span> <span class="mi">252</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL.O</th>
      <th>MSFT.O</th>
      <th>SPY</th>
      <th>GLD</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>AAPL.O</th>
      <td>0.063710</td>
      <td>0.023364</td>
      <td>0.021015</td>
      <td>0.001497</td>
    </tr>
    <tr>
      <th>MSFT.O</th>
      <td>0.023364</td>
      <td>0.050965</td>
      <td>0.022193</td>
      <td>-0.000337</td>
    </tr>
    <tr>
      <th>SPY</th>
      <td>0.021015</td>
      <td>0.022193</td>
      <td>0.021858</td>
      <td>0.000041</td>
    </tr>
    <tr>
      <th>GLD</th>
      <td>0.001497</td>
      <td>-0.000337</td>
      <td>0.000041</td>
      <td>0.026063</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can also annualize everything at the end, after the optimization. The optimizer will work just fine with daily data, but you have to keep in mind that you’ll need a daily risk-free rate and that you’re finding a daily Sharpe ratio.</p>
</div>
<p>When you form a portfolio, you of course need to know how much of your portfolio is in each asset. Let’s pick some <strong>random weights</strong> to start. We’ll do that by choosing random numbers between 0 and 1. How many random numbers? The variable <em>noa</em> has the number of assets stored in it, so we’ll pick four. Then, we’ll divide each random number by the sum of the four numbers. This “trick” let’s us go from four numbers between 0 and 1 to four numbers that will add up to 1. Just like portfolio weights!</p>
<p>Note the <code class="docutils literal notranslate"><span class="pre">/=</span></code>. This divides every item in <em>weights</em> by the sum of the weights and then saves the result back to <em>weights</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">noa</span><span class="p">)</span>
<span class="n">weights</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.9999999999999998
</pre></div>
</div>
</div>
</div>
<p>Good! They add up to 1. Or, well, basically 1. Remember, computers try their best to store exact numbers, but there’s only so much precision that you can get.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ann_rets</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.140787455752856
</pre></div>
</div>
</div>
</div>
<p>We can also find portfolio variance using the random weights. Again, we’re annualizing variances and covariances.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rets</span><span class="o">.</span><span class="n">cov</span><span class="p">()</span> <span class="o">*</span> <span class="mi">252</span><span class="p">,</span> <span class="n">weights</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.023790295597565476
</pre></div>
</div>
</div>
</div>
<p>Finally, we take the square root of variance to get standard deviation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rets</span><span class="o">.</span><span class="n">cov</span><span class="p">()</span> <span class="o">*</span> <span class="mi">252</span><span class="p">,</span> <span class="n">weights</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.15424103084965907
</pre></div>
</div>
</div>
</div>
<p>Ok, all of this was with random weights. Can we do any better than that, if we assume that our expected returns and variance co-variance matrix represent our best guess about how these assets will behave in the future? Note that his is a really big assumption. The past might not tells us much about the future.</p>
</div>
<div class="section" id="plotting-the-efficient-frontier">
<h2>Plotting the efficient frontier<a class="headerlink" href="#plotting-the-efficient-frontier" title="Permalink to this headline">¶</a></h2>
<p>The efficient frontier represents the relationship between risk and return. Each point on the curve is the best return that you can get for a given level of risk. Or, equivalently, each point is the lowest risk that you can take for a particular expected return. We would expect to see a positive relationship between risk and return.</p>
<div class="figure align-center" id="cal-2-png">
<img alt="../_images/10-cal.png" src="../_images/10-cal.png" />
<p class="caption"><span class="caption-number">Fig. 23 </span><span class="caption-text">The Capital Allocation Line, or CAL. The mean-variance frontier is the highest return you can get for a given level of risk. The CAL is all possible combinations have the highest Sharpe Ratio portfolio (the tangency portfolio) and the risk-free asset. If all investors have the same beliefs about all underlying assets, then they will all hold the same market portfolio, just in different quantities, depending on their risk preferences. Source: Asset Management by Andrew Ang</span><a class="headerlink" href="#cal-2-png" title="Permalink to this image">¶</a></p>
</div>
<p>What if we picked a bunch of random portfolios, found their risk and return, and then plotted each on a scatter plot? We should see the efficient frontier “emerge” as we essentially throw darts, since some risk-return combinations are not possible for a given set of assets. There’s only so much return you can get for a given level of risk.</p>
<p>To do this, let’s define two functions. One just takes weights and finds the portfolio return using the mean returns. The other finds the volatility of the portfolio using the weights passed to it. Note that both are just the formulas used above, but now in a function that we’ve defined.</p>
<p>How do you <strong>read the format of a user defined function</strong>? You use <code class="docutils literal notranslate"><span class="pre">def</span></code> to define the function name. Inside of <code class="docutils literal notranslate"><span class="pre">()</span></code>, you put the items that are getting passed, or given to, the function. In this case, whatever we give the function will be called <em>weights</em> inside of the function. What’s inside the function. You must end the first line with a <code class="docutils literal notranslate"><span class="pre">:</span></code>. Then, you need to <strong>indent everything that happens when the function is used</strong>. In this case, that’s just one line. The function will <strong>return</strong> whatever is on the line with <strong>return</strong>. In this case, the portfolio return and volatility.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">port_ret</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ann_rets</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">port_vol</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rets</span><span class="o">.</span><span class="n">cov</span><span class="p">()</span> <span class="o">*</span> <span class="mi">252</span><span class="p">,</span> <span class="n">weights</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
<p>Here’s the main part. We are going to use those two functions above to write some cleaner code. We start by creating two empty arrays, <em>prets</em> and <em>pvols</em>. We’ll then put a bunch of different portfolio mean returns and volatilities into these arrays. How are we going to get these different portfolio risk and return characteristics? Let’s create a bunch of random portfolios with random asset weights. In fact, let’s create 2500 random portfolios and see what each combination of risk and return looks like when we plot it. The shape should look familiar!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">prets</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">pvols</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">2500</span><span class="p">):</span>  
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">noa</span><span class="p">)</span>  
    <span class="n">weights</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>  
    <span class="n">prets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">port_ret</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>  
    <span class="n">pvols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">port_vol</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>  
<span class="n">prets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prets</span><span class="p">)</span>
<span class="n">pvols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pvols</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The <strong>for</strong> statement will have the value <em>p</em> go from 0 to 2499 (i.e. 2500 times). For each of these times through the loop, we calculate our random weights and the portfolio returns and volatility for these weights, using the same expected returns and volatility for the assets each time through. Only the weights are changing. We then <strong>append</strong>, or stack, the return and volatility values on top of each other, creating two <strong>lists</strong> with 2500 numbers in them. But, we don’t want a list. We want an <strong>array</strong> of numbers. The last two lines convert the lists into <code class="docutils literal notranslate"><span class="pre">numpy</span></code> arrays which we can graph.</p>
<p>Let’s graph them. We’ll make a <strong>scatter plot</strong> with volatility on the x-axis and returns on the y-axis. The <code class="docutils literal notranslate"><span class="pre">c=</span></code> option adds a third dimension to the graph, where we pick a color for each dot based on another value. That value is the return for that dot divided by the volatility of that dot. In other words, darker red means bigger return over risk ratio, or larger <strong>Sharpe Ratio</strong>. Notice how the dark red is along the edge of the curve? This is the <strong>efficient frontier</strong>!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pvols</span><span class="p">,</span> <span class="n">prets</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">prets</span> <span class="o">/</span> <span class="n">pvols</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;coolwarm&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;expected volatility&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;expected return&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Sharpe ratio&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/9_portfolio_opt_25_0.png" src="../_images/9_portfolio_opt_25_0.png" />
</div>
</div>
<p>We’ve just generated the <strong>efficient frontier</strong> from a simulation. No “formulas”, per se. Just make 2500 random portfolios and at least some of them are going to be good!</p>
<p>Each portfolio on the <strong>envelope</strong>, the edge of the shape we see above, is on the efficient frontier. Each of these portfolios has the highest return for a given level of risk (or the lowest risk for a given return).</p>
<p>We’ll draw the efficient frontier below.</p>
</div>
<div class="section" id="optimizing">
<h2>Optimizing<a class="headerlink" href="#optimizing" title="Permalink to this headline">¶</a></h2>
<p>Let’s use an <strong>optimizer</strong> actually find the portfolio with the best Sharpe Ratio. This will be, for a given risk-free rate, the single portfolio with the best risk-reward trade-off.</p>
<p>We’ll also find the portfolio with the lower volatility (risk). This portfolio is sometimes called the <strong>minimum variance portfolio</strong>.</p>
<p>We will assume in this example that the risk-free rate is zero. We are not subtracting the risk-free rate from the portfolio return in the numerator. Note that as you change the risk-free rate, then you get different maximum Sharpe Ratio portfolios. What you’re doing, graphically, is <strong>tracing</strong> out the efficient frontier, finding different porfolios that are on the envelope.</p>
<div class="section" id="finding-the-max-sharpe-portfolio">
<h3>Finding the max Sharpe portfolio<a class="headerlink" href="#finding-the-max-sharpe-portfolio" title="Permalink to this headline">¶</a></h3>
<p>We’ll start by defining a new function. This is our <strong>Sharpe Ratio</strong>. The optimization process that we’re going to use wants to find the <strong>minimum</strong> of something. So, we’ll make the Sharpe Ratio negative. This will then be the equivalent of finding the **maximum.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">min_func_sharpe</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>  
    <span class="k">return</span> <span class="o">-</span><span class="n">port_ret</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="n">port_vol</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>  
</pre></div>
</div>
</div>
</div>
<p>That’s the function that we are going to <strong>minimize</strong>. We are going to have Python find the weights that make that function as small as possible. Again, since the function has a negative sign in front, this is like finding the maximum.</p>
<p>Portfolio optimization always has a <strong>constraint</strong> where your weights must add up to one. To add this constraint, we are now going to set up a <strong>dictionary</strong> that our optimizer is going to be able to understand. The dictionary will say that we are going to give the optimizer something that is type <code class="docutils literal notranslate"><span class="pre">eq</span></code>, or an equation, and that the equation is the sum of all of our weights minus 1. The optimizer is going to know that we want this to be set equal to zero when solving for weights. In other words, all of our weights must add up to one - we are forcing the optimizer to to this.</p>
<p>By the way, see the <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">x:</span></code>? This is a <strong>lambda</strong>, or anonymous, function. These let us quickly and easily define a simple function. In this case, we have a function that is going to take an argument <em>x</em> and then do something with it. We are adding up all of the elements of <em>x</em> and then subtracting one. When we use this function, <em>x</em> will be our weights.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cons</span> <span class="o">=</span> <span class="p">({</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;eq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">})</span>  
<span class="nb">type</span><span class="p">(</span><span class="n">cons</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>dict
</pre></div>
</div>
</div>
</div>
<p>We can now put some bounds on our weights. Weights, in this case, need to be between 0 and 1. This isn’t always the case! For example, short-selling means having weights less than 0. Leverage means weights greater than 1, potentially. To do this, we’ll create a <strong>tuple</strong> that has the set (0,1) for each asset in our portfolio, four in this case. This will tell the optimizer to keep each asset weight between 0 and 1.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">bnds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">noa</span><span class="p">))</span>  
<span class="n">bnds</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>((0, 1), (0, 1), (0, 1), (0, 1))
</pre></div>
</div>
</div>
</div>
<p>We’ll start by giving the optimizer an equally-weighted portfolio. It will change these weights to find the ones that minimize that negative Sharpe Ratio. This code will generate an array with equal weights, no matter how many assets you are using.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eweights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">noa</span> <span class="o">*</span> <span class="p">[</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">noa</span><span class="p">,])</span>  
<span class="n">eweights</span>  
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0.25, 0.25, 0.25, 0.25])
</pre></div>
</div>
</div>
</div>
<p>Here’s the negative Sharpe Ratio with the equal-weights. So, the “real” Sharpe is 1.09.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">min_func_sharpe</span><span class="p">(</span><span class="n">eweights</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-0.9936699253973043
</pre></div>
</div>
</div>
</div>
<p>Finally, let’s use the optimizer! We are going to use <code class="docutils literal notranslate"><span class="pre">sco.minimize</span></code> from the library <code class="docutils literal notranslate"><span class="pre">SciPy</span></code>, which we have brought in above. This function is like <strong>Solver in Excel</strong>. It is going to find the minimum value of some function by changing a set of variables in the function, subject to some constraints. The first argument is the function to minimize. The second argument is the initial guess. Then, we give it the method to use to find the minimum value. We’re using something called Sequential Least Squares Programming (SLSQP) here. Not important for us. We then give the optimizer our bounds for the variables and the constraints.</p>
<p>You can read more about this function in the <code class="docutils literal notranslate"><span class="pre">SciPy</span></code> manual <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">here</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">opts</span> <span class="o">=</span> <span class="n">sco</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">min_func_sharpe</span><span class="p">,</span> <span class="n">eweights</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bnds</span><span class="p">,</span>
                    <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">)</span> 
<span class="nb">type</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>scipy.optimize.optimize.OptimizeResult
</pre></div>
</div>
</div>
</div>
<p>We’ve saved the results in this OptimizeResult <strong>object</strong>. This object contains information about our optimization, including the optimal values it found. It calls these <em>x</em> - they are our weights that give us the minimum negative (i.e. maximum) Sharpe Ratio.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">opts</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>     fun: -1.039672055952566
     jac: array([-6.12437725e-06, -2.13503838e-04,  5.58644533e-05,  3.93256545e-04])
 message: &#39;Optimization terminated successfully&#39;
    nfev: 35
     nit: 7
    njev: 7
  status: 0
 success: True
       x: array([0.50109745, 0.23793622, 0.14449823, 0.1164681 ])
</pre></div>
</div>
</div>
</div>
<p>Let’s pull out just the weights from the object and round to three decimal palces.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">opts</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0.501, 0.238, 0.144, 0.116])
</pre></div>
</div>
</div>
</div>
<p>Here’s the portfolio return with those weights.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">port_ret</span><span class="p">(</span><span class="n">opts</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.18
</pre></div>
</div>
</div>
</div>
<p>And the portfolio volatility with those weights.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">port_vol</span><span class="p">(</span><span class="n">opts</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.173
</pre></div>
</div>
</div>
</div>
<p>And, the Sharpe Ratio with those weights.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">port_ret</span><span class="p">(</span><span class="n">opts</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="n">port_vol</span><span class="p">(</span><span class="n">opts</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>  
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.039672055952566
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="finding-the-minimum-variance-portfolio">
<h3>Finding the minimum variance portfolio.<a class="headerlink" href="#finding-the-minimum-variance-portfolio" title="Permalink to this headline">¶</a></h3>
<p>We can do the same things and find the set of weights that <strong>minimize portfolio variance</strong>. Instead of minimizing the negative of the Sharpe Ratio, we’ll minimize the function that contains the formula for portfolio volatility, <em>port_vol</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">optv</span> <span class="o">=</span> <span class="n">sco</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">port_vol</span><span class="p">,</span> <span class="n">eweights</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bnds</span><span class="p">,</span>
                    <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">)</span>  
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">optv</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>     fun: 0.10912534155379648
     jac: array([0.11099017, 0.10919402, 0.10910396, 0.10915083])
 message: &#39;Optimization terminated successfully&#39;
    nfev: 45
     nit: 9
    njev: 9
  status: 0
 success: True
       x: array([1.40946282e-18, 0.00000000e+00, 5.43849155e-01, 4.56150845e-01])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">optv</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0.   , 0.   , 0.544, 0.456])
</pre></div>
</div>
</div>
</div>
<p>Nothing in our first asset, Apple. Since we are just minimizing variance, we don’t care about Apple’s nice return over this period.</p>
<p>We can find the Sharpe Ratio for the minimum variance portfolio. Note how it is lower!</p>
<p>Also, finding minimum variance and minimum volatility are the <strong>same thing</strong>, since volatility is just the square root of variance.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">port_vol</span><span class="p">(</span><span class="n">optv</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.109
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">port_ret</span><span class="p">(</span><span class="n">optv</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.072
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">port_ret</span><span class="p">(</span><span class="n">optv</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="n">port_vol</span><span class="p">(</span><span class="n">optv</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.6605053013045209
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="efficient-frontier">
<h2>Efficient Frontier<a class="headerlink" href="#efficient-frontier" title="Permalink to this headline">¶</a></h2>
<p>Let’s now trace out the actual <strong>efficient frontier</strong>. We are going to follow an “algorithm”, so to speak. Here are the steps:</p>
<ol class="simple">
<li><p>Pick a target return.</p></li>
<li><p>Find the portfolio that gives you the minimum portfolio standard deviation (volatility) for that target return.</p></li>
<li><p>Repeat this process for a large number of target returns.</p></li>
</ol>
<p>These steps will find a bunch of different portfolios, all that live on the envelope of the set containing all of the possible portfolios. These are the portfolios on the efficient frontier.</p>
<p>To do this, we now need two constraints. First, we want our portfolio return to be equal to some target return, <em>tret</em>. Second, we again have our weights must sum to one constraint.</p>
<p>Both of these constraints can live inside of the <em>cons</em> tuple. This <strong>tuple</strong> contains two <strong>dictionaries</strong>. Kind of confusing, but we just need to understand the syntax for writing out different constraints. The only part that changes is the code after <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">x:</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cons</span> <span class="o">=</span> <span class="p">({</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;eq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>  <span class="n">port_ret</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">tret</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;eq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">})</span>  
<span class="nb">type</span><span class="p">(</span><span class="n">cons</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>tuple
</pre></div>
</div>
</div>
</div>
<p>Our bounds again, same as before.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">bnds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s create an <strong>array</strong> of values from 0.05 to 0.20. This represents a minimum of a 5% return and a maximum of a 20% return. We’ll do 50 evenly-spaced values. Each one of these represents one target return. We are going to find and store the minimum volatility that gives us each return.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">trets</span><span class="p">))</span>
<span class="n">trets</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;numpy.ndarray&#39;&gt;
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0.05      , 0.05306122, 0.05612245, 0.05918367, 0.0622449 ,
       0.06530612, 0.06836735, 0.07142857, 0.0744898 , 0.07755102,
       0.08061224, 0.08367347, 0.08673469, 0.08979592, 0.09285714,
       0.09591837, 0.09897959, 0.10204082, 0.10510204, 0.10816327,
       0.11122449, 0.11428571, 0.11734694, 0.12040816, 0.12346939,
       0.12653061, 0.12959184, 0.13265306, 0.13571429, 0.13877551,
       0.14183673, 0.14489796, 0.14795918, 0.15102041, 0.15408163,
       0.15714286, 0.16020408, 0.16326531, 0.16632653, 0.16938776,
       0.17244898, 0.1755102 , 0.17857143, 0.18163265, 0.18469388,
       0.1877551 , 0.19081633, 0.19387755, 0.19693878, 0.2       ])
</pre></div>
</div>
</div>
</div>
<p>And here’s the optimization process. We start with an empty array that will eventually contain 50 different volatilities (standard deviations). Then, we loop through each target return in <em>trets</em>. Each one gets stored in <em>tret</em> and used in the For loop. The optimizer uses that target return as part of the constraint function that we included. We are then storing the value of the minimized portfolio volatility function in <em>tvols</em>. Note that we are not storing the weights for each portfolio. We only care about the minimum volatilities for each return.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%%time</span>
<span class="n">tvols</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">tret</span> <span class="ow">in</span> <span class="n">trets</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">sco</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">port_vol</span><span class="p">,</span> <span class="n">eweights</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span>
                       <span class="n">bounds</span><span class="o">=</span><span class="n">bnds</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">)</span>  
    <span class="n">tvols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;fun&#39;</span><span class="p">])</span>
<span class="n">tvols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tvols</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>CPU times: user 9.82 s, sys: 124 ms, total: 9.95 s
Wall time: 1.25 s
</pre></div>
</div>
</div>
</div>
<p>And now we can plot our efficient frontier. The efficient frontier is each <strong>target return, minimum volatility pair</strong>. That blue line is the frontier and is being added by the first <code class="docutils literal notranslate"><span class="pre">plt.plot</span></code> statement. The second <code class="docutils literal notranslate"><span class="pre">plt.plot</span></code> adds the yellow star at the max Sharpe Ratio portfolio. The third <code class="docutils literal notranslate"><span class="pre">plt.plot</span></code> adds the red star at the global minimum variance portfolio. Notice how both of these are pulling the weights, <em>x</em>, out of their respective Optimizer objects.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pvols</span><span class="p">,</span> <span class="n">prets</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">prets</span> <span class="o">/</span> <span class="n">pvols</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;coolwarm&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tvols</span><span class="p">,</span> <span class="n">trets</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">4.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">port_vol</span><span class="p">(</span><span class="n">opts</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span> <span class="n">port_ret</span><span class="p">(</span><span class="n">opts</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span>
         <span class="s1">&#39;y*&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mf">15.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">port_vol</span><span class="p">(</span><span class="n">optv</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span> <span class="n">port_ret</span><span class="p">(</span><span class="n">optv</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]),</span>
         <span class="s1">&#39;r*&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mf">15.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;expected volatility&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;expected return&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Sharpe ratio&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/9_portfolio_opt_69_0.png" src="../_images/9_portfolio_opt_69_0.png" />
</div>
</div>
</div>
<div class="section" id="pyportfolioopt">
<h2>PyPortfolioOpt<a class="headerlink" href="#pyportfolioopt" title="Permalink to this headline">¶</a></h2>
<p>To get started, you’ll need to type <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">PyPortfolioOpt</span></code> in your Terminal below. This will install the package, since it doesn’t come with Anaconda. We can then bring in what we need.</p>
<p>You can read all about the <code class="docutils literal notranslate"><span class="pre">PyPortfolioOpt</span></code> package <a class="reference external" href="https://pypi.org/project/pyportfolioopt/">here</a>.</p>
<p>You can also find examples on the author’s <a class="reference external" href="https://github.com/robertmartin8/PyPortfolioOpt/tree/master/cookbook">Github page</a>. The creator of this package is <a class="reference external" href="https://reasonabledeviations.com/about/">a recent Cambridge graduate, not much older than you</a>.</p>
<div class="figure align-center" id="pyport-png">
<img alt="../_images/09-pyport.png" src="../_images/09-pyport.png" />
<p class="caption"><span class="caption-number">Fig. 24 </span><span class="caption-text">The portfolio optimization process. Source: PyPortfolioOpt</span><a class="headerlink" href="#pyport-png" title="Permalink to this image">¶</a></p>
</div>
<p>This <a class="reference external" href="https://pyportfolioopt.readthedocs.io/en/latest/UserGuide.html">page</a> takes the explanations on the Github page and provides some nicer formatting.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pypfopt.efficient_frontier</span> <span class="kn">import</span> <span class="n">EfficientFrontier</span>
<span class="kn">from</span> <span class="nn">pypfopt</span> <span class="kn">import</span> <span class="n">risk_models</span><span class="p">,</span> <span class="n">expected_returns</span><span class="p">,</span> <span class="n">plotting</span>
</pre></div>
</div>
</div>
</div>
<p>We can find expected returns and the sample variance-covariance matrix using functions from <code class="docutils literal notranslate"><span class="pre">PyPortfolioOpt</span></code>. Notice that these functions want prices, not returns, by default. So, I’m using the DataFrame <em>data</em>, not <em>ret</em>. You can change this setting with the argument <code class="docutils literal notranslate"><span class="pre">returns_data</span> <span class="pre">=</span> <span class="pre">True</span></code>.</p>
<p>I’ll start by finding returns from prices.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rets_pyp</span> <span class="o">=</span> <span class="n">expected_returns</span><span class="o">.</span><span class="n">returns_from_prices</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">rets_pyp</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL.O</th>
      <th>MSFT.O</th>
      <th>SPY</th>
      <th>GLD</th>
    </tr>
    <tr>
      <th>Date</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2010-01-05</th>
      <td>0.001729</td>
      <td>0.000323</td>
      <td>0.002647</td>
      <td>-0.000911</td>
    </tr>
    <tr>
      <th>2010-01-06</th>
      <td>-0.015906</td>
      <td>-0.006137</td>
      <td>0.000704</td>
      <td>0.016500</td>
    </tr>
    <tr>
      <th>2010-01-07</th>
      <td>-0.001849</td>
      <td>-0.010335</td>
      <td>0.004221</td>
      <td>-0.006188</td>
    </tr>
    <tr>
      <th>2010-01-08</th>
      <td>0.006648</td>
      <td>0.006830</td>
      <td>0.003328</td>
      <td>0.004963</td>
    </tr>
    <tr>
      <th>2010-01-11</th>
      <td>-0.008822</td>
      <td>-0.012720</td>
      <td>0.001397</td>
      <td>0.013289</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2018-06-25</th>
      <td>-0.014871</td>
      <td>-0.020118</td>
      <td>-0.013613</td>
      <td>-0.003739</td>
    </tr>
    <tr>
      <th>2018-06-26</th>
      <td>0.012406</td>
      <td>0.007013</td>
      <td>0.002214</td>
      <td>-0.005255</td>
    </tr>
    <tr>
      <th>2018-06-27</th>
      <td>-0.001464</td>
      <td>-0.015543</td>
      <td>-0.008284</td>
      <td>-0.005702</td>
    </tr>
    <tr>
      <th>2018-06-28</th>
      <td>0.007276</td>
      <td>0.011175</td>
      <td>0.005717</td>
      <td>-0.003036</td>
    </tr>
    <tr>
      <th>2018-06-29</th>
      <td>-0.002102</td>
      <td>-0.000203</td>
      <td>0.001440</td>
      <td>0.003637</td>
    </tr>
  </tbody>
</table>
<p>2137 rows × 4 columns</p>
</div></div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rets</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL.O</th>
      <th>MSFT.O</th>
      <th>SPY</th>
      <th>GLD</th>
    </tr>
    <tr>
      <th>Date</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2010-01-05</th>
      <td>0.001729</td>
      <td>0.000323</td>
      <td>0.002647</td>
      <td>-0.000911</td>
    </tr>
    <tr>
      <th>2010-01-06</th>
      <td>-0.015906</td>
      <td>-0.006137</td>
      <td>0.000704</td>
      <td>0.016500</td>
    </tr>
    <tr>
      <th>2010-01-07</th>
      <td>-0.001849</td>
      <td>-0.010335</td>
      <td>0.004221</td>
      <td>-0.006188</td>
    </tr>
    <tr>
      <th>2010-01-08</th>
      <td>0.006648</td>
      <td>0.006830</td>
      <td>0.003328</td>
      <td>0.004963</td>
    </tr>
    <tr>
      <th>2010-01-11</th>
      <td>-0.008822</td>
      <td>-0.012720</td>
      <td>0.001397</td>
      <td>0.013289</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2018-06-25</th>
      <td>-0.014871</td>
      <td>-0.020118</td>
      <td>-0.013613</td>
      <td>-0.003739</td>
    </tr>
    <tr>
      <th>2018-06-26</th>
      <td>0.012406</td>
      <td>0.007013</td>
      <td>0.002214</td>
      <td>-0.005255</td>
    </tr>
    <tr>
      <th>2018-06-27</th>
      <td>-0.001464</td>
      <td>-0.015543</td>
      <td>-0.008284</td>
      <td>-0.005702</td>
    </tr>
    <tr>
      <th>2018-06-28</th>
      <td>0.007276</td>
      <td>0.011175</td>
      <td>0.005717</td>
      <td>-0.003036</td>
    </tr>
    <tr>
      <th>2018-06-29</th>
      <td>-0.002102</td>
      <td>-0.000203</td>
      <td>0.001440</td>
      <td>0.003637</td>
    </tr>
  </tbody>
</table>
<p>2137 rows × 4 columns</p>
</div></div></div>
</div>
<p>We can compare that with our original return file and see that this function is calculating discrete returns by default, since the returns are the same. We can use the package to find annualized returns too. I’ll give the function the price data again. I will also set compounding to False, as we don’t typically use annualized geometric means (CAGRs) for portfolio optimization. I want arithmetic means. The default for this function is that you have daily returns, or 252 time periods.</p>
<p>However, the annualization simply takes the monthly arithmetic mean and multiplies by 252. This is why the average returns we’re using are lower than the ones above.</p>
<p>But, I’ll add each option, just so that you can that they are there.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mu</span> <span class="o">=</span> <span class="n">expected_returns</span><span class="o">.</span><span class="n">mean_historical_return</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">compounding</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">log_returns</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">frequency</span> <span class="o">=</span> <span class="mi">252</span><span class="p">)</span>
<span class="n">mu</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>AAPL.O    0.244313
MSFT.O    0.162139
SPY       0.113901
GLD       0.022214
dtype: float64
</pre></div>
</div>
</div>
</div>
<p>You can actually see the <a class="reference external" href="https://github.com/robertmartin8/PyPortfolioOpt/blob/master/pypfopt/expected_returns.py">code for these functions</a>. I like looking through code like this to both learn what these functions are doing, what my options are, etc., as well as learning how to write better Python myself!</p>
<p>You can see how the function is getting the annual returns by just multiplying by 252, the number of trading days.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rets</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">*</span><span class="mi">252</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>AAPL.O    0.244313
MSFT.O    0.162139
SPY       0.113901
GLD       0.022214
dtype: float64
</pre></div>
</div>
</div>
</div>
<p>The package author has a good comment in his documents about the issues with using historical data for returns:</p>
<blockquote>
<div><p>This is probably the default textbook approach. It is intuitive and easily interpretable,
however the estimates are subject to large uncertainty. This is a problem especially in the
context of a mean-variance optimizer, which will maximise the erroneous inputs.</p>
</div></blockquote>
<p>In other words, the assets with the largest historical returns are likely the assets with the greatest estimation error. But, the simplest optimization methods, like what we’re doing, will choose those assets! And, the same is true for the worst performing assets. Their negative performance might be exaggerated too.</p>
<p>Next, we can create and store the <strong>sample variance-covariance matrix</strong>. “Sample” means that we are using sample variance and covariance (as opposed to population variance and covariance).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="n">risk_models</span><span class="o">.</span><span class="n">sample_cov</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">S</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>AAPL.O</th>
      <th>MSFT.O</th>
      <th>SPY</th>
      <th>GLD</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>AAPL.O</th>
      <td>0.063710</td>
      <td>0.023364</td>
      <td>0.021015</td>
      <td>0.001497</td>
    </tr>
    <tr>
      <th>MSFT.O</th>
      <td>0.023364</td>
      <td>0.050965</td>
      <td>0.022193</td>
      <td>-0.000337</td>
    </tr>
    <tr>
      <th>SPY</th>
      <td>0.021015</td>
      <td>0.022193</td>
      <td>0.021858</td>
      <td>0.000041</td>
    </tr>
    <tr>
      <th>GLD</th>
      <td>0.001497</td>
      <td>-0.000337</td>
      <td>0.000041</td>
      <td>0.026063</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">PyPortfolioOpt</span></code> has built-in plotting functions that create <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> plots, among other plot types. Here’s one showing the correlations among our four assets. Gold immediately stands out.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plotting</span><span class="o">.</span><span class="n">plot_covariance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">plot_correlation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;AxesSubplot:&gt;
</pre></div>
</div>
<img alt="../_images/9_portfolio_opt_83_1.png" src="../_images/9_portfolio_opt_83_1.png" />
</div>
</div>
<p>Let’s find our max Sharpe portfolio. We’ll do this step-by-step. First, we’ll use the function <code class="docutils literal notranslate"><span class="pre">EfficientFrontier</span></code> to find and create an object that contains the information needed to describe the efficient frontier for these assets. Note that you just need the expected returns and the variance-covariance matrix to define the efficient frontier.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ef</span> <span class="o">=</span> <span class="n">EfficientFrontier</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
<span class="n">ef</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;pypfopt.efficient_frontier.efficient_frontier.EfficientFrontier at 0x7f8278687730&gt;
</pre></div>
</div>
</div>
</div>
<p>This <em>ef</em> object contains useful things. For example, it let’s us pull our the max Sharpe portfolio for a given risk-free rate. Remember, you pick a risk-free rate and draw that tangency line over to the efficient frontier. So, different assumed risk-free rates give you different max Sharpe portfolios.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">raw_weights</span> <span class="o">=</span> <span class="n">ef</span><span class="o">.</span><span class="n">max_sharpe</span><span class="p">(</span><span class="n">risk_free_rate</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">)</span>
<span class="n">raw_weights</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>OrderedDict([(&#39;AAPL.O&#39;, 0.688149209643207),
             (&#39;MSFT.O&#39;, 0.311850790356793),
             (&#39;SPY&#39;, 0.0),
             (&#39;GLD&#39;, 0.0)])
</pre></div>
</div>
</div>
</div>
<p>This comes out as a type of <strong>Dictionary</strong>. We can use <code class="docutils literal notranslate"><span class="pre">clean_weights()</span></code> to get rid of some of the decimal places.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cleaned_weights</span> <span class="o">=</span> <span class="n">ef</span><span class="o">.</span><span class="n">clean_weights</span><span class="p">()</span>
<span class="n">cleaned_weights</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>OrderedDict([(&#39;AAPL.O&#39;, 0.68815),
             (&#39;MSFT.O&#39;, 0.31185),
             (&#39;SPY&#39;, 0.0),
             (&#39;GLD&#39;, 0.0)])
</pre></div>
</div>
</div>
</div>
<p>Finally, we can pull out the return and risk characteristics of this max Sharpe portfolio with that assumed risk-free rate.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">perf</span> <span class="o">=</span> <span class="n">ef</span><span class="o">.</span><span class="n">portfolio_performance</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">risk_free_rate</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">)</span>
<span class="n">perf</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Expected annual return: 21.9%
Annual volatility: 21.2%
Sharpe Ratio: 0.91
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.21868665539725798, 0.2124945591992392, 0.9114899512116612)
</pre></div>
</div>
</div>
</div>
<p>You can even access the individual values in this <em>perf</em> <code class="docutils literal notranslate"><span class="pre">tuple</span></code> I created. Here’s the expected annual return</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">perf</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>tuple
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">perf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.21868665539725798
</pre></div>
</div>
</div>
</div>
<p>This package does much more than this. I encourage you to take a look! Here’s one additional example, with two changes. First, I’ve added some weight bounds for the assets added to the <code class="docutils literal notranslate"><span class="pre">EfficientFrontier</span></code> method. Second, instead of finding the max Sharpe portfolio, I’m using <code class="docutils literal notranslate"><span class="pre">ef.efficient_return</span></code> to find the portfolio with the least amount of risk that gives a target return of 18%.</p>
<p>You can see from the output below that we did indeed hit our target return.</p>
<p>See how Apple hits the upper limit I set of 50%? Apple did so well during this period that the optimizer really wants us to put most of money in it. Is that a good idea?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ef</span> <span class="o">=</span> <span class="n">EfficientFrontier</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">weight_bounds</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="n">raw_weights</span> <span class="o">=</span> <span class="n">ef</span><span class="o">.</span><span class="n">efficient_return</span><span class="p">(</span><span class="n">target_return</span> <span class="o">=</span> <span class="mf">0.18</span><span class="p">,</span> <span class="n">market_neutral</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">cleaned_weights</span> <span class="o">=</span> <span class="n">ef</span><span class="o">.</span><span class="n">clean_weights</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cleaned_weights</span><span class="p">)</span>
<span class="n">ef</span><span class="o">.</span><span class="n">portfolio_performance</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>OrderedDict([(&#39;AAPL.O&#39;, 0.5), (&#39;MSFT.O&#39;, 0.2387), (&#39;SPY&#39;, 0.14546), (&#39;GLD&#39;, 0.11584)])
Expected annual return: 18.0%
Annual volatility: 17.3%
Sharpe Ratio: 0.92
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(0.17999999999999997, 0.17313170716569976, 0.9241519223677973)
</pre></div>
</div>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./chapters"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="8_port_math.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Essential portfolio math</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="10_factor_models.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Factor models <a id='factor_models'></a></p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Prof. Adam Aiken<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>